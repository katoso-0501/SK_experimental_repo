<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1> Duel </h1>
    <p>
    `Duel` is a JavaScript class that manages a turn-based battle between two characters.  
It handles combat logic, action resolution, and game state progression in a simple duel simulation.

---

### Definition

The `Duel` class orchestrates a battle between two `LeadChar` instances (`charA` and `charB`). It initializes character stats, determines turn order based on agility (`agl`), and runs a loop via `draw()` and `seekTurn()` until one or both characters are defeated.

```javascript
102:295:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
class Duel {
    constructor(rules) {
        this.rules = rules;
        this.message = "";
        this.totalMessage = "";
        this.gameFlag = 1; // 1 = active, 0 = ended
        this.totalTurn = 0;
        this.sideA = ["*", "*", "*", "*", "*", "*"]; // unused placeholder
        this.sideB = ["*", "*", "*", "*", "*", "*"]; // unused placeholder
        this.orders = []; // determines turn order

        // Create two lead characters with randomized stats
        this.charA = new LeadChar(this, { /* randomized stats */ });
        this.charB = new LeadChar(this, { /* randomized stats */ });

        // Ensure unique names
        if (this.charA.stats.charName === this.charB.stats.charName) {
            this.charA.stats.charName += "A";
            this.charB.stats.charName += "B";
        }

        this.writeMessage("The engage!");
        this.parallelProgress(); // Starts animation loop
    }

    determineOrder() { /* sets turn order based on agility + randomness */ }
    draw() { /* starts turn loop with setTimeout */ }
    seekTurn() { /* executes actions per turn */ }
    charNormalBash(origin, target) { /* deals damage */ }
    charDefend(origin) { /* sets guard state */ }
    charLifeUp(origin) { /* heals to full HP if enough TP */ }
    charSetAction(origin, target) { /* AI-driven action selection */ }
    writeMessage(msg) { /* updates UI message */ }
    writeBreakdown(msg) { /* logs message history */ }
    parallelProgress() { /* runs animation frame loop for HP/TP bars */ }
    terminate() { /* ends game, displays result */ }
}
```

- **Purpose**: Manages a single duel instance between two AI-controlled characters.
- **Params**: `rules` – an object that configures game behavior (e.g. `{ duelmode: "normal" }` enables magic).
- **Side effects**: 
  - Modifies DOM elements (`.message_container`, `.breakdown_container`).
  - Starts a recursive `setTimeout` loop via `draw()`.
  - Uses `requestAnimationFrame` for smooth HP/TP bar updates.
- **State tracking**: 
  - `gameFlag`: controls whether the duel is active.
  - `orders`: queue of characters waiting to act.
  - `totalTurn`: increments each round.
- **AI behavior**: Uses `determineMainCharAction()` to simulate decision-making with weighted randomness.

---

### Example Usages

The `Duel` class is instantiated once at runtime to start a new duel. It runs autonomously with no player input.

```javascript
337:338:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
let game = new Duel({ duelmode: "normal" });
setTimeout(() => { game.draw(); }, 1000);
```

This creates a new duel with normal rules (magic enabled) and starts the battle loop after a 1-second delay. The `draw()` method calls `seekTurn()` every second, advancing the fight turn by turn.

**Overall Usage in Codebase**:
- `Duel` is defined and used in a single file: `main.js`.
- It is instantiated exactly once via the `game` variable.
- No other files or modules reference `Duel`, making it the root of the application’s logic.
- The duel is fully automatic — characters act based on randomized AI decisions.

---

### Notes

- Despite having `sideA` and `sideB` arrays of six elements each, the system only uses two characters (`charA` and `charB`). The arrays appear to be placeholders for potential future expansion (e.g. team battles), but are currently unused.
- The `parallelProgress()` method uses `window.requestAnimationFrame()` recursively to animate HP and TP bars smoothly, while `draw()` uses `setTimeout` for turn pacing — a dual timing strategy.
- Critical hits and misses are implemented with `Math.random()*16 <= 1`, giving roughly a 6.25% chance for each.

---

### See Also

- `LeadChar`: The character class used by `Duel`; extends `CharBase` and manages UI elements and stat updates.
- `CharBase`: Base class for characters, stores shared stats and provides `setStats()`.
- `determineMainCharAction(origin)`: Standalone function that simulates AI decision-making by sampling possible actions.
- `characterNames`: Array of Japanese names used to randomly name characters (e.g., "そう", "メイプル").
        
    </p>

    <h1>Determine Main Char Action</h1>
    <p>
        `determineMainCharAction` is a standalone function that simulates AI decision-making for characters in a duel system.

It determines the next action (e.g., attack, defend, heal) a character will take based on their current state, using weighted randomness and health/TP thresholds.

---

### Definition

```javascript
297:327:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
function determineMainCharAction(origin) {
    const opinions = [];                     // Collects 10 proposed actions
    const player = origin.stats;             // Shortcut to character stats
    let action;

    for (let i = 0; i < 10; i++) {
        action = "bash";                     // Default action: attack

        // 10% chance to choose "defend" instead
        if (Math.random() * 10 <= 1) {
            action = "defend";
        }

        // If TP >= 24 and HP is low, consider "lifeup" (heal)
        if (player.tp >= 24 && player.hp < player.mhp) {
            if (player.hpa <= player.mhp * 0.7 && Math.random() * 6 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= player.mhp * 0.4 && Math.random() * 3 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= 100) {
                action = "lifeup";           // Always heal if HP <= 100
            }
        }

        opinions.push(action);               // Store this iteration's choice
    }

    console.log(origin.stats.charName + "のしこう : " + opinions.join("、"));

    // Final decision: randomly pick one of the 10 proposed actions
    const finalDecision = opinions[Math.floor(Math.random() * opinions.length)];
    return finalDecision;
}
```

- **Params**: `origin` – a `LeadChar` instance with `.stats` containing HP, TP, and other character attributes
- **Returns**: A string: `"bash"`, `"defend"`, `"lifeup"`, or (rarely) undefined
- **Side effects**: Logs decision log to console; no DOM or game state modifications
- **Logic**: Simulates deliberation by sampling 10 possible actions with weighted rules, then randomly selects one

---

### Example Usages

The function is called during each turn in the duel loop to decide what a character should do. It is used exclusively within the `charSetAction` method of the `Duel` class.

```javascript
235:246:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
charSetAction(origin, target) {
    const action = determineMainCharAction(origin);  // Get AI decision

    if (action === "bash") {
        this.charNormalBash(origin, target);
    } else if (action === "defend") {
        this.charDefend(origin);
    } else if (action === "lifeup") {
        this.charLifeUp(origin);
    } else {
        this.writeMessage(`${origin.stats.charName} は たちすくんだ！`);
    }
}
```

**Usage Flow**:
1. `draw()` triggers `seekTurn()` every second via `setTimeout`
2. `seekTurn()` calls `charSetAction()` for the next character in `orders`
3. `charSetAction()` calls `determineMainCharAction(origin)` to get the AI's choice
4. The chosen action is executed

This function is used **twice per turn** (once per character) and runs fully autonomously—no player input is involved.

---

### Notes

- Despite generating 10 opinions, the final choice is uniformly random across them—there is no bias toward majority decisions.
- The healing logic has three tiers: probabilistic at 70% and 40% HP, and **mandatory** at 100 HP or below, making it aggressive about survival.
- The 10% chance to defend is unconditional and can override healing, introducing risk of suboptimal choices—this adds unpredictability, mimicking human-like hesitation.

---

### See Also

- `LeadChar`: The character class whose instances are passed as `origin`; holds stats and UI elements.
- `Duel`: The main game loop class; calls `determineMainCharAction` via `charSetAction` during turns.
- `charSetAction(origin, target)`: The method that consumes the result of `determineMainCharAction` and executes the corresponding action.
- `characterNames`: Array of Japanese names used to randomly name characters (e.g., "そう", "メイプル"), visible in logs and messages.
    </p>
    <h1>Char Normal Bash</h1>
    <p>
        Two-line introduction
- **charNormalBash** is a function that executes a basic attack action in a duel.

- In short, it computes damage, handles possible misses or critical hits, applies defense reduction, and updates TP/hp as appropriate during a fight turn.

Definition
This section reproduces the most relevant parts of the implementation to help understanding. The code is paraphrased for readability. See the original for exact syntax in the repository context.

```typescript
205:        charNormalBash (origin, target) {
206:            // base damage: random in [30, 149]
207:            let damage =  Math.floor(Math.random()*120) + 30;
208:
209:            // announce the attack
210:            this.writeMessage(`${origin.stats.charName} の こうげき！`);
211:            // 1/16 chance to miss
212:            if(Math.random()*16 <= 1){
213:                this.writeMessage(`The missed!`);
214:            }else{
215:                // 1/16 chance for a critical hit
216:                if(Math.random()*16 <= 1){
217:                    damage = damage * 3;
218:                    this.writeMessage(`Critical hit!`);
219:                }else if(target.stats.isDefending) {
220:                    // if target is defending, reduce damage to 30%
221:                    damage = Math.floor(damage * 0.3);
222:                }
223:                // increase attacker's TP by 1 (capped elsewhere)
224:                origin.stats.tp++;
225:                // apply damage to target HP
226:                target.stats.hp -= damage;
227:                // log damage breakdown
228:                this.writeBreakdown(`${damage} ダメージ`);
229:            }
230:        }
```

- Basic information:
  - **Params**: 
    - origin: character performing the bash (object with stats including tp, name, etc.)
    - target: character receiving the attack (object with stats.hp, isDefending, etc.)
  - **Returns**: void (side effects: writes messages, updates TP, HP)
  - **Side effects**: writes action messages, updates target.hp, increments origin.tp, logs breakdown
  - **Notes**: includes randomness for miss and critical hit; if target is defending, damage is reduced to 30%; critical hit multiplies by 3x

- Related context:
  - This method is invoked from charSetAction when the AI decides to perform a bash.
  - See the surrounding flow for how actions are chosen and how turns progress (seekTurn, determineOrder, draw).

Enhanced context (why this matters)
- The function models a turn-based combat mechanic with simple RPG-like randomness: miss chance, crit chance, and guard mitigation.
- TP (technique points) are increased on successful hit to enable abilities like Life Up later (e.g., Life Up logic consumes TP to fully heal the user).
- The interaction with defending status is an important defensive mechanic; it directly reduces incoming damage when defending.
- The code logs both immediate messages (e.g., “critical hit”) and a breakdown line that records the numeric damage, enabling UI and history features to reflect the duel.

Example usages
- Using the function in a typical turn:
  - The AI decides to perform a bash.
  - charNormalBash(origin, target) computes damage with randomness.
  - If hit, TP increases, HP of target decreases, and a breakdown line is logged.
  - If miss, a miss message is shown and no damage is applied.

Code snippet illustrating usage (paraphrased):
```javascript
// During a turn, the AI selects "bash" and calls the attack
this.charNormalBash(attacker, defender);
```

- Practical in-file references:
  - charNormalBash is called by charSetAction when action === "bash".
  - The same function appears in multiple copies of the file (the project includes similar copies in different builds/locations; usage remains the same).

See Also
- charSetAction: the dispatcher that selects actions including charNormalBash
- charDefend: defense action that interacts with the damaged calculation
- determineMainCharAction: decides a given character’s action tendencies
- Duel: the class coordinating the fight loop, order, and terminal conditions

Notes
- The symbol is implemented as a method of the LeadChar/ Duel context and relies on shared utilities like writeMessage and writeBreakdown for UI/logging.
- There are multiple copies of similarly named methods in the codebase due to file structure variations; the logic for charNormalBash remains consistent across these references.

Code blocks (enhanced location format)
- For reference, the key portion defining charNormalBash is presented above with paraphrased readability. The original source lines are shown in the code block for clarity.

See Also references in the repository
- charSetAction: chooses between bash/defend/lifeup
- determineMainCharAction: AI decision engine that influences whether bash will be called
- writeMessage / writeBreakdown: UI and logging helpers used by the action methods

End of article.
    </p>


    <h1>Life Up</h1>
    <p>

        `lifeUp` is a method on a character class that attempts to heal the character using a PSI spell.  
    It checks TP cost and silence status before executing a full heal via `spellBook.lifeup.func`.
    
    ---
    
    ### Definition
    
    The `lifeUp` method is a member of a character class (likely `LeadChar` or similar) in a turn-based duel system. It represents the action of using the "Life Up" PSI ability, which fully restores the user's HP if conditions are met.
    
    ```javascript
    183:200:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
    lifeUp () {
        // Announce the action
        this.duel.writeMessage(`${this.stats.charName} は ライフアップ をこころみた！`);
    
        setTimeout(()=>{
            // Check TP and silence ailment
            if (this.stats.tp >= spellBook.lifeup.cost && this.stats.ailments.silenced === 0) {
                spellBook.lifeup.func(this, this.duel); // Execute healing
            } else if (this.stats.ailments.silenced) {
                this.duel.writeMessage(`しかし PSIは ふうじこまれている！`);
            } else {
                this.duel.writeMessage(`しかし TPがたりなかった！`);
            }
        }, 1200);
    
        // End action phase after delay
        setTimeout(() => {
            this.windowMain.classList.remove("acting");
            this.duel.seekTurn();
        }, 2000);
    }
    ```
    
    - **Params**: None (bound to character instance via `this`)
    - **Side effects**: 
      - Writes messages to duel log via `this.duel.writeMessage`
      - May reduce user's TP and fully restore HP via `spellBook.lifeup.func`
      - Removes `"acting"` class from UI element
      - Triggers next turn via `this.duel.seekTurn()`
    - **Returns**: `undefined`
    - **Conditions**: Requires 24 TP and not silenced
    
    The actual healing logic is defined externally in `spellBook.lifeup.func`, which deducts TP and sets HP to maximum.
    
    ---
    
    ### Example Usages
    
    `lifeUp` is invoked during a character's turn when the AI decides to heal. The decision is made by `determineMainCharAction`, which evaluates HP, TP, and randomness.
    
    ```javascript
    136:138:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
    } else if(action === "lifeup") {
        this.lifeUp();
    }
    ```
    
    In practice, `lifeUp` is called only when:
    - The character has at least 24 TP (as defined in `spellBook.lifeup.cost`)
    - The character is not silenced
    - The AI simulation (in `determineMainCharAction`) randomly selects "lifeup" based on HP thresholds
    
    The AI logic (from `deepwiki.html`) shows that healing is prioritized when:
    - HP ≤ 70% with 1/6 chance
    - HP ≤ 40% with 1/3 chance
    - HP ≤ 100 (hard threshold)
    
    This method is part of a larger turn resolution system triggered by `initAction → setAction → lifeUp`.
    
    ---
    
    ### Notes
    
    - Despite the name `lifeUp`, the method does **not directly heal**—it only attempts to cast the spell. The actual healing is delegated to `spellBook.lifeup.func`.
    - The 1200ms delay ensures the message appears before resolution, simulating casting time.
    - `lifeUp` is one of only three valid actions (`bash`, `defend`, `lifeup`) returned by the AI decision function.
    
    ---
    
    ### See Also
    
    - `spellBook.lifeup`: Object defining the cost (24 TP) and healing function; `lifeUp` depends on it for execution
    - `determineMainCharAction`: AI function that returns `"lifeup"` as a possible action based on HP/TP state
    - `initAction`: Top-level method that starts the action chain leading to `lifeUp`
    - `LeadChar`: Likely class containing `lifeUp`; manages character state and actions in duels
    </p>

    <h1>Terminate</h1>
    <p>
        `terminate` is a method that ends a duel instance and displays the result.<br >
It is called when both characters are defeated or when revival is not possible.<br >
<br >
---<br >
<br >
### Definition<br >
<br >
The `terminate` method is part of a duel management class in `main.js`, responsible for ending a duel between two AI-controlled characters. It stops the game loop, clears action orders, updates character states, and renders the outcome in the UI.<br >
<br >
```javascript<br >
<br >
terminate () {<br >
    this.gameFlag = 0;                    // Stop the game loop<br >
    this.orders = [];                     // Clear turn queue<br >
<br >
    // Handle draw condition: both characters defeated
    if (this.charB.stats.hpa === 0 && this.charA.stats.hpa === 0) {
        this.charB.stats.hp = 0;
        this.charA.stats.hp = 0;
        this.charB.stats.hpa = 0;
        this.charA.stats.hpa = 0;
        this.writeMessage(`りょうしゃとも きずつきたおれた…`); // Both fighters fell...
        this.writeBreakdown(`Draw!`);
    } 
    // B is defeated, A wins
    else if (this.charB.stats.hpa <= 0) {
        this.writeMessage(`${this.charB.stats.charName} は きずつきたおれた…`); // ...has fallen
        this.writeBreakdown(`${this.charA.stats.charName} Wins!`);
    }
    // A is defeated, B wins
    else if (this.charA.stats.hpa <= 0) {
        this.writeMessage(`${this.charA.stats.charName} は きずつきたおれた…`);
        this.writeBreakdown(`${this.charB.stats.charName} Wins!`);
    } 
    // Otherwise: manual termination (e.g., game reset)
    else {
        this.writeMessage(`しあいは ちゅうしされた！`); // The match was suspended!
        this.writeBreakdown(`Draw!`);
    }

    // Trigger final UI updates
    this.charA.parallelProgress();
    this.charB.parallelProgress();

    // Add "Show Breakdown" button to view full log
    const showBrkdwnBtn = document.createElement('div');
    showBrkdwnBtn.textContent = "うちわけを ひょうじする"; // Show breakdown
    showBrkdwnBtn.classList.add("showBreakdownBtn");
    this.duelScreen.appendChild(showBrkdwnBtn);

    const brkdwnContainer = document.createElement("div");
    brkdwnContainer.classList.add("breakdownContainer");
    brkdwnContainer.innerHTML = String(this.totalMessage).replace(/\n/g, "<br>");
    this.duelScreen.appendChild(brkdwnContainer);

    // Toggle visibility on click
    showBrkdwnBtn.addEventListener('click', () => {
        brkdwnContainer.classList.toggle("expanded");
        this.duelScreen.classList.toggle("scrollable");
    });
}
```

- **Params**: None  
- **Side effects**:  
  - Sets `this.gameFlag = 0`, halting the `requestAnimationFrame` loop in `parallelProgress()`  
  - Clears `this.orders`, stopping turn execution  
  - Modifies DOM: appends a results UI with message, winner, and expandable log  
  - Calls `writeMessage()` and `writeBreakdown()` to update displayed text  
- **Returns**: `undefined`  

---

### Example Usages

`terminate` is called from `seekTurn()` when a character is defeated and cannot be revived. It acts as the final step in duel resolution.

```javascript
463:471:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
seekTurn () {
    if (this.charB.stats.hpa <= 0 && this.charA.stats.hpa <= 0) {
        this.charA.faint();
        this.charB.faint();
        this.terminate(); // End duel immediately
    } else if (this.charB.stats.hpa <= 0) {
        this.charB.faint();
        if (this.charB.stats.reviveEnchanted === 0) {
            this.terminate(); // No revival available → end duel
        } else {
            // Revive sequence triggered instead
            this.writeMessage(`${this.charB.stats.charName} は きずつきたおれた…`);
            setTimeout(() => {
                this.charB.invokeRevive();
            }, 1000);
        }
    }
    // ...similar logic for charA...
}
```

Overall, `terminate` is called in three main scenarios:
1. Both fighters are defeated → draw
2. One fighter is defeated and cannot revive → opponent wins
3. Manual interruption (fallback case)

It is used exclusively within the duel lifecycle, primarily by `seekTurn()`, and is central to game state resolution.

---

### Notes

- Despite being called `terminate`, the function does **not** remove DOM elements or clean up event listeners beyond toggling UI states. Cleanup appears partial.
- The method calls `parallelProgress()` on both characters *after* setting `gameFlag = 0`, ensuring one final UI sync before freeze.
- The Japanese messages suggest this is a fan-made or localized RPG battle simulator, possibly inspired by games like *EarthBound* or *Mother*.

---

### See Also

- `seekTurn`: Primary caller of `terminate`; evaluates game state each turn and triggers end conditions  
- `faint`: Called before `terminate`; sets character visual/UI state to "defeated"  
- `parallelProgress`: Animation loop that `terminate` stops by setting `gameFlag = 0`  
- `writeMessage` / `writeBreakdown`: Used to display results; `writeBreakdown` logs persistent text for the final summary panel  
- `invokeRevive`: Alternative to `terminate` when revival is possible; delays game end
    </p>
</body>
</html>