<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <h1> Duel </h1>
    <p>
    `Duel` is a JavaScript class that manages a turn-based battle between two characters.  
It handles combat logic, action resolution, and game state progression in a simple duel simulation.

---

### Definition

The `Duel` class orchestrates a battle between two `LeadChar` instances (`charA` and `charB`). It initializes character stats, determines turn order based on agility (`agl`), and runs a loop via `draw()` and `seekTurn()` until one or both characters are defeated.

```javascript
102:295:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
class Duel {
    constructor(rules) {
        this.rules = rules;
        this.message = "";
        this.totalMessage = "";
        this.gameFlag = 1; // 1 = active, 0 = ended
        this.totalTurn = 0;
        this.sideA = ["*", "*", "*", "*", "*", "*"]; // unused placeholder
        this.sideB = ["*", "*", "*", "*", "*", "*"]; // unused placeholder
        this.orders = []; // determines turn order

        // Create two lead characters with randomized stats
        this.charA = new LeadChar(this, { /* randomized stats */ });
        this.charB = new LeadChar(this, { /* randomized stats */ });

        // Ensure unique names
        if (this.charA.stats.charName === this.charB.stats.charName) {
            this.charA.stats.charName += "A";
            this.charB.stats.charName += "B";
        }

        this.writeMessage("The engage!");
        this.parallelProgress(); // Starts animation loop
    }

    determineOrder() { /* sets turn order based on agility + randomness */ }
    draw() { /* starts turn loop with setTimeout */ }
    seekTurn() { /* executes actions per turn */ }
    charNormalBash(origin, target) { /* deals damage */ }
    charDefend(origin) { /* sets guard state */ }
    charLifeUp(origin) { /* heals to full HP if enough TP */ }
    charSetAction(origin, target) { /* AI-driven action selection */ }
    writeMessage(msg) { /* updates UI message */ }
    writeBreakdown(msg) { /* logs message history */ }
    parallelProgress() { /* runs animation frame loop for HP/TP bars */ }
    terminate() { /* ends game, displays result */ }
}
```

- **Purpose**: Manages a single duel instance between two AI-controlled characters.
- **Params**: `rules` – an object that configures game behavior (e.g. `{ duelmode: "normal" }` enables magic).
- **Side effects**: 
  - Modifies DOM elements (`.message_container`, `.breakdown_container`).
  - Starts a recursive `setTimeout` loop via `draw()`.
  - Uses `requestAnimationFrame` for smooth HP/TP bar updates.
- **State tracking**: 
  - `gameFlag`: controls whether the duel is active.
  - `orders`: queue of characters waiting to act.
  - `totalTurn`: increments each round.
- **AI behavior**: Uses `determineMainCharAction()` to simulate decision-making with weighted randomness.

---

### Example Usages

The `Duel` class is instantiated once at runtime to start a new duel. It runs autonomously with no player input.

```javascript
337:338:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
let game = new Duel({ duelmode: "normal" });
setTimeout(() => { game.draw(); }, 1000);
```

This creates a new duel with normal rules (magic enabled) and starts the battle loop after a 1-second delay. The `draw()` method calls `seekTurn()` every second, advancing the fight turn by turn.

**Overall Usage in Codebase**:
- `Duel` is defined and used in a single file: `main.js`.
- It is instantiated exactly once via the `game` variable.
- No other files or modules reference `Duel`, making it the root of the application’s logic.
- The duel is fully automatic — characters act based on randomized AI decisions.

---

### Notes

- Despite having `sideA` and `sideB` arrays of six elements each, the system only uses two characters (`charA` and `charB`). The arrays appear to be placeholders for potential future expansion (e.g. team battles), but are currently unused.
- The `parallelProgress()` method uses `window.requestAnimationFrame()` recursively to animate HP and TP bars smoothly, while `draw()` uses `setTimeout` for turn pacing — a dual timing strategy.
- Critical hits and misses are implemented with `Math.random()*16 <= 1`, giving roughly a 6.25% chance for each.

---

### See Also

- `LeadChar`: The character class used by `Duel`; extends `CharBase` and manages UI elements and stat updates.
- `CharBase`: Base class for characters, stores shared stats and provides `setStats()`.
- `determineMainCharAction(origin)`: Standalone function that simulates AI decision-making by sampling possible actions.
- `characterNames`: Array of Japanese names used to randomly name characters (e.g., "そう", "メイプル").
        
    </p>

    <h1>Determine Main Char Action</h1>
    <p>
        `determineMainCharAction` is a standalone function that simulates AI decision-making for characters in a duel system.

It determines the next action (e.g., attack, defend, heal) a character will take based on their current state, using weighted randomness and health/TP thresholds.

---

### Definition

```javascript
297:327:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
function determineMainCharAction(origin) {
    const opinions = [];                     // Collects 10 proposed actions
    const player = origin.stats;             // Shortcut to character stats
    let action;

    for (let i = 0; i < 10; i++) {
        action = "bash";                     // Default action: attack

        // 10% chance to choose "defend" instead
        if (Math.random() * 10 <= 1) {
            action = "defend";
        }

        // If TP >= 24 and HP is low, consider "lifeup" (heal)
        if (player.tp >= 24 && player.hp < player.mhp) {
            if (player.hpa <= player.mhp * 0.7 && Math.random() * 6 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= player.mhp * 0.4 && Math.random() * 3 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= 100) {
                action = "lifeup";           // Always heal if HP <= 100
            }
        }

        opinions.push(action);               // Store this iteration's choice
    }

    console.log(origin.stats.charName + "のしこう : " + opinions.join("、"));

    // Final decision: randomly pick one of the 10 proposed actions
    const finalDecision = opinions[Math.floor(Math.random() * opinions.length)];
    return finalDecision;
}
```

- **Params**: `origin` – a `LeadChar` instance with `.stats` containing HP, TP, and other character attributes
- **Returns**: A string: `"bash"`, `"defend"`, `"lifeup"`, or (rarely) undefined
- **Side effects**: Logs decision log to console; no DOM or game state modifications
- **Logic**: Simulates deliberation by sampling 10 possible actions with weighted rules, then randomly selects one

---

### Example Usages

The function is called during each turn in the duel loop to decide what a character should do. It is used exclusively within the `charSetAction` method of the `Duel` class.

```javascript
235:246:c:\Users\katos\Desktop\2020A-Katoso\ads\assets\js\main.js
charSetAction(origin, target) {
    const action = determineMainCharAction(origin);  // Get AI decision

    if (action === "bash") {
        this.charNormalBash(origin, target);
    } else if (action === "defend") {
        this.charDefend(origin);
    } else if (action === "lifeup") {
        this.charLifeUp(origin);
    } else {
        this.writeMessage(`${origin.stats.charName} は たちすくんだ！`);
    }
}
```

**Usage Flow**:
1. `draw()` triggers `seekTurn()` every second via `setTimeout`
2. `seekTurn()` calls `charSetAction()` for the next character in `orders`
3. `charSetAction()` calls `determineMainCharAction(origin)` to get the AI's choice
4. The chosen action is executed

This function is used **twice per turn** (once per character) and runs fully autonomously—no player input is involved.

---

### Notes

- Despite generating 10 opinions, the final choice is uniformly random across them—there is no bias toward majority decisions.
- The healing logic has three tiers: probabilistic at 70% and 40% HP, and **mandatory** at 100 HP or below, making it aggressive about survival.
- The 10% chance to defend is unconditional and can override healing, introducing risk of suboptimal choices—this adds unpredictability, mimicking human-like hesitation.

---

### See Also

- `LeadChar`: The character class whose instances are passed as `origin`; holds stats and UI elements.
- `Duel`: The main game loop class; calls `determineMainCharAction` via `charSetAction` during turns.
- `charSetAction(origin, target)`: The method that consumes the result of `determineMainCharAction` and executes the corresponding action.
- `characterNames`: Array of Japanese names used to randomly name characters (e.g., "そう", "メイプル"), visible in logs and messages.
    </p>
    <h1>Char Normal Bash</h1>
    <p>
        Two-line introduction
- **charNormalBash** is a function that executes a basic attack action in a duel.

- In short, it computes damage, handles possible misses or critical hits, applies defense reduction, and updates TP/hp as appropriate during a fight turn.

Definition
This section reproduces the most relevant parts of the implementation to help understanding. The code is paraphrased for readability. See the original for exact syntax in the repository context.

```typescript
205:        charNormalBash (origin, target) {
206:            // base damage: random in [30, 149]
207:            let damage =  Math.floor(Math.random()*120) + 30;
208:
209:            // announce the attack
210:            this.writeMessage(`${origin.stats.charName} の こうげき！`);
211:            // 1/16 chance to miss
212:            if(Math.random()*16 <= 1){
213:                this.writeMessage(`The missed!`);
214:            }else{
215:                // 1/16 chance for a critical hit
216:                if(Math.random()*16 <= 1){
217:                    damage = damage * 3;
218:                    this.writeMessage(`Critical hit!`);
219:                }else if(target.stats.isDefending) {
220:                    // if target is defending, reduce damage to 30%
221:                    damage = Math.floor(damage * 0.3);
222:                }
223:                // increase attacker's TP by 1 (capped elsewhere)
224:                origin.stats.tp++;
225:                // apply damage to target HP
226:                target.stats.hp -= damage;
227:                // log damage breakdown
228:                this.writeBreakdown(`${damage} ダメージ`);
229:            }
230:        }
```

- Basic information:
  - **Params**: 
    - origin: character performing the bash (object with stats including tp, name, etc.)
    - target: character receiving the attack (object with stats.hp, isDefending, etc.)
  - **Returns**: void (side effects: writes messages, updates TP, HP)
  - **Side effects**: writes action messages, updates target.hp, increments origin.tp, logs breakdown
  - **Notes**: includes randomness for miss and critical hit; if target is defending, damage is reduced to 30%; critical hit multiplies by 3x

- Related context:
  - This method is invoked from charSetAction when the AI decides to perform a bash.
  - See the surrounding flow for how actions are chosen and how turns progress (seekTurn, determineOrder, draw).

Enhanced context (why this matters)
- The function models a turn-based combat mechanic with simple RPG-like randomness: miss chance, crit chance, and guard mitigation.
- TP (technique points) are increased on successful hit to enable abilities like Life Up later (e.g., Life Up logic consumes TP to fully heal the user).
- The interaction with defending status is an important defensive mechanic; it directly reduces incoming damage when defending.
- The code logs both immediate messages (e.g., “critical hit”) and a breakdown line that records the numeric damage, enabling UI and history features to reflect the duel.

Example usages
- Using the function in a typical turn:
  - The AI decides to perform a bash.
  - charNormalBash(origin, target) computes damage with randomness.
  - If hit, TP increases, HP of target decreases, and a breakdown line is logged.
  - If miss, a miss message is shown and no damage is applied.

Code snippet illustrating usage (paraphrased):
```javascript
// During a turn, the AI selects "bash" and calls the attack
this.charNormalBash(attacker, defender);
```

- Practical in-file references:
  - charNormalBash is called by charSetAction when action === "bash".
  - The same function appears in multiple copies of the file (the project includes similar copies in different builds/locations; usage remains the same).

See Also
- charSetAction: the dispatcher that selects actions including charNormalBash
- charDefend: defense action that interacts with the damaged calculation
- determineMainCharAction: decides a given character’s action tendencies
- Duel: the class coordinating the fight loop, order, and terminal conditions

Notes
- The symbol is implemented as a method of the LeadChar/ Duel context and relies on shared utilities like writeMessage and writeBreakdown for UI/logging.
- There are multiple copies of similarly named methods in the codebase due to file structure variations; the logic for charNormalBash remains consistent across these references.

Code blocks (enhanced location format)
- For reference, the key portion defining charNormalBash is presented above with paraphrased readability. The original source lines are shown in the code block for clarity.

See Also references in the repository
- charSetAction: chooses between bash/defend/lifeup
- determineMainCharAction: AI decision engine that influences whether bash will be called
- writeMessage / writeBreakdown: UI and logging helpers used by the action methods

End of article.
    </p>
</body>
</html>