

**************************************
CharBase.parallelProgress.ailmentSuffix       *
**************************************
`ailmentSuffix` is a local string variable that dynamically constructs a human-readable label for active status ailments on a character in a duel system.  
It aggregates Japanese text representations of various negative status conditions (e.g. poison, paralysis) based on the current state of a character’s `ailments` object.

This variable is not globally accessible or directly invoked—it exists solely within the scope of the `parallelProgress` method of the `CharBase` class, where it is used to update the character's UI display. Its primary purpose is to provide real-time visual feedback about a character’s afflictions during gameplay.

---

### Definition

The `ailmentSuffix` variable is defined inside the `parallelProgress` method of the `CharBase` class. It uses template literal syntax to conditionally concatenate Japanese status labels based on boolean values in the `this.stats.ailments` object.

```javascript
401:403:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
const a = this.stats.ailments;
const ailmentSuffix = 
    `${a.poisoned ? "どく " : ""}` +
    `${a.paralysed ? "まひ " : ""}` +
    `${a.asleep ? "ねむり " : ""}` +
    `${a.strange ? "へん " : ""}` +
    `${a.crying ? "なみだとまらない" : ""}` +
    `${a.silenced ? "PSIふういん" : ""}`;
```

- **Type**: `string` (constructed from conditional expressions)
- **Scope**: Local to the `parallelProgress()` method
- **Side effects**: None — it is a pure derivation from current state
- **Purpose**: To generate a space-separated string of Japanese status effect names reflecting active ailments
- **Used in**: Updating `this.charContainer.textContent` for UI display

The resulting `ailmentSuffix` value is appended to the character’s HP readout, allowing players to see at a glance which status effects are currently active.

---

### Example Usages

The `ailmentSuffix` is used exactly once in the codebase, within the same function where it is defined. It contributes to updating the character’s status display in the UI.

```javascript
405:406:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
this.charContainer.textContent = 
    `${this.stats.charName} : HP ${this.stats.hp} ${ailmentSuffix}`;
```

This line sets the visible text of a character’s status container to include their name, current HP, and any active ailments—such as `"ナターシャ : HP 42 どく まひ "` if both poisoned and paralyzed.

**Usage Summary**:  
- Called exclusively within `parallelProgress()`  
- Invoked on every frame update cycle for each character  
- Part of the core UI refresh mechanism in the duel system  
- Used by both player (`LeadChar`) and AI-controlled characters inheriting from `CharBase`  
- Central to user feedback during status-based combat mechanics  

It is not exported, referenced elsewhere, or logged—it serves a single, focused role in presentation logic.

---

### Notes

- Despite its name suggesting a suffix in English, `ailmentSuffix` contains full Japanese words rather than abbreviated or grammatical suffixes—this may reflect localization conventions in the game's design.
- The space at the end of each condition (e.g. `"どく "`) ensures readable separation when multiple ailments are present, but could lead to trailing whitespace; however, this does not affect rendering.
- The order of conditions in the string is fixed and does not prioritize severity or duration, meaning less critical effects like `"へん "` (strange) appear alongside more impactful ones like `"PSIふういん"` (PSI seal).

---

### See Also

- `CharBase`: Base class for all duel participants; defines `parallelProgress()` and holds `stats.ailments`. This is where `ailmentSuffix` is constructed and used.
- `parallelProgress()`: The method responsible for synchronizing character stats and UI elements each frame; `ailmentSuffix` is a key part of its display logic.
- `stats.ailments`: An object on each character containing boolean flags for each status effect; directly drives the value of `ailmentSuffix`.
- `LeadChar`: Subclass of `CharBase` representing player characters; inherits the use of `ailmentSuffix` through `parallelProgress`.



******************************
Duel                        *
******************************
`Duel` is a JavaScript class that manages a turn-based battle between two AI-controlled characters.  
It simulates a fully automatic duel with dynamic rules, character actions, and UI feedback.

---

### Definition

The `Duel` class orchestrates a battle between two `LeadChar` instances (`charA` and `charB`). It initializes character stats, determines turn order based on agility (`agl`), and runs a loop via `parallelProgress()` and `seekTurn()` to advance the fight. The duel proceeds autonomously—no player input is required.

```javascript
487:750:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
class Duel {
    constructor(rules) {
        // Create UI elements
        this.duelScreen = document.createElement("div");
        this.duelScreen.classList.add("duelScreen");
        this.messageBox = document.createElement('div');
        this.messageBox.classList.add('messageContainer');
        this.windowContainer = document.createElement('div');
        this.windowContainer.classList.add('windowFlexBox');
        this.duelScreen.appendChild(this.messageBox);
        this.duelScreen.appendChild(this.windowContainer);
        document.querySelector("main").appendChild(this.duelScreen);

        this.startTime = performance.now();
        this.rules = rules;
        this.totalMessage = "";
        this.gameFlag = 1; // 1 = active, 0 = ended
        this.totalTurn = 0;
        this.hitPointSetting = [];
        this.technicalPointSetting = [];

        // Set HP/TP based on duel mode
        for(let k = 0; k < 2; k++){
            if(this.rules.duelmode === "suddendeath") {
                this.hitPointSetting.push(1);
            } else if(this.rules.duelmode === "poisonrelying"){
                this.hitPointSetting.push(999);
            } else {
                this.hitPointSetting.push(Math.floor(Math.random()*520) + 350);
            }

            if(this.rules.duelmode === "suddendeath" || this.rules.duelmode === "nomagic" || this.rules.duelmode === "poisonrelying") {
                this.technicalPointSetting.push(0);
            } else {
                this.technicalPointSetting.push(Math.floor(Math.random()*500) + 250);
            }
        }

        // Initialize characters
        this.sideA = [new LeadChar(this, { /* stats */ }), "*", "*", "*", "*", "*"];
        this.sideB = [new LeadChar(this, { /* stats */ }), "*", "*", "*", "*", "*"];
        this.charA = this.sideA[0];
        this.charB = this.sideB[0];
        this.charA.opponent = this.charB;
        this.charB.opponent = this.charA;

        if(this.charA.stats.charName === this.charB.stats.charName){
            this.charA.stats.charName += "A";
            this.charB.stats.charName += "B";
        }

        this.writeBreakdown(`ルール：${this.rules.japanname}`);
        this.writeMessage("The engage!");
        this.parallelProgress();
    }

    determineOrder() { /* randomize turn order with slight agl variance */ }
    seekTurn() { /* process next action, check win/loss, revive if possible */ }
    writeMessage(msg) { this.messageBox.innerHTML = msg; this.writeBreakdown(msg); }
    writeBreakdown(msg) { this.totalMessage += msg + "\n"; }
    parallelProgress() { /* animate HP/TP bars via requestAnimationFrame */ }
    terminate() { /* end duel, display result, show breakdown */ }
}
```

- **Params**: `rules` – an object defining game behavior (e.g. `{ duelmode: "normal", japanname: "ふつうのデュエル" }`)
- **Side effects**: 
  - Modifies DOM: adds `.duelScreen`, updates `.messageBox`, appends `.breakdownContainer` on end
  - Starts animation loop via `requestAnimationFrame(parallelProgress)`
  - Triggers character actions and AI decisions
- **State tracking**: 
  - `gameFlag`: controls whether the duel is active
  - `orders`: queue of characters waiting to act
  - `totalTurn`: increments each round
- **AI behavior**: Uses `determineMainCharAction()` to simulate decision-making with weighted randomness

---

### Example Usages

The `Duel` class is instantiated when a user clicks one of several UI buttons, each starting a duel under different rules. It runs autonomously after creation.

```javascript
914:918:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
document.querySelector('.normalDuelBtn').addEventListener('click', ()=>{
    const a = new Duel({duelmode: "normal", japanname: "ふつうのデュエル", background : 0});
    duelMain.push(a);
    setTimeout(()=>{a.seekTurn();}, 1000);
});
```

Other rule variants include:
- `"nomagic"`: disables PSI abilities (TP = 0)
- `"suddendeath"`: both characters start with 1 HP
- `"poisonrelying"`: characters start with 999 HP and no TP
- `"withrevive"`: allows revival after defeat
- `"30seconds"`: automatically terminates after 30 seconds

Each mode alters gameplay significantly. For example, in `suddendeath`, the first successful hit wins.

---

### Notes

- Despite having `sideA` and `sideB` arrays of six elements each, only the first element (`sideA[0]`, `sideB[0]`) is used. The rest are placeholders, suggesting potential for future expansion (e.g. team battles).
- The `parallelProgress()` method uses `window.requestAnimationFrame()` recursively to animate HP and TP bars smoothly, while `seekTurn()` is triggered via `setTimeout`—a dual timing strategy balancing visual smoothness and turn pacing.
- Critical hits and misses are implemented with `Math.random()*16 <= 1`, giving roughly a 6.25% chance for each.

---

### See Also

- `LeadChar`: The character class used by `Duel`; extends `CharBase` and manages UI elements and stat updates.
- `CharBase`: Base class for characters, stores shared stats and provides `setStats()`.
- `determineMainCharAction(origin)`: Standalone function that simulates AI decision-making by sampling possible actions.
- `characterNames`: Array of Japanese names used to randomly name characters (e.g., "そう", "メイプル").
- `terminate()`: Method that ends the duel, displays results, and appends a scrollable breakdown log.


******************************
Duel.terminate              *
******************************
`terminate` is a method that ends a duel session in an automated battle simulation.

It finalizes the game state, displays match results, and disables further actions when a duel concludes due to character defeat, time limit, or mutual knockout.

---

### Definition

The `terminate` method is part of a duel management class in `main.js`, responsible for cleanly ending a duel instance. It stops game execution, logs final outcomes, and renders post-match UI elements such as result messages and damage summaries.

```javascript
702:749:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
terminate () {
    const endTime = performance.now() - this.startTime;
    this.gameFlag = 0;           // Stops game loop
    this.orders = [];            // Clears action queue

    // Case: Both characters are defeated
    if (this.charB.stats.hpa === 0 && this.charA.stats.hpa === 0) {
        this.writeMessage(`りょうしゃとも きずつきたおれた…`); // "Both fighters have fallen..."
        this.writeBreakdown(`Draw!`);
    }
    // Case: Character B is defeated
    else if (this.charB.stats.hpa <= 0) {
        this.writeMessage(`${this.charB.stats.charName} は きずつきたおれた…`);
        this.writeBreakdown(`${this.charA.stats.charName} Wins!`);
    }
    // Case: Character A is defeated
    else if (this.charA.stats.hpa <= 0) {
        this.writeMessage(`${this.charA.stats.charName} は きずつきたおれた…`);
        this.writeBreakdown(`${this.charB.stats.charName} Wins!`);
    }
    // Fallback: Game ended prematurely (e.g., time limit)
    else {
        this.writeMessage(`しあいは ちゅうしされた！`); // "The match was suspended!"
        this.writeBreakdown(`Draw!`);
    }

    // Final stats logging
    this.writeBreakdown(`せんとうじかん : ${minutes} ふん ${seconds} びょう`); // Combat time
    this.writeBreakdown(`${charA.name} が うけた ダメージ : ${this.charA.takenDamage}`);
    this.writeBreakdown(`${charB.name} が うけた ダメージ : ${this.charB.takenDamage}`);

    // Injects "Show Breakdown" button and damage log container into DOM
    const showBrkdwnBtn = document.createElement('div');
    showBrkdwnBtn.textContent = "うちわけを ひょうじする"; // "Show breakdown"
    showBrkdwnBtn.classList.add("showBreakdownBtn");
    this.duelScreen.appendChild(showBrkdwnBtn);

    const brkdwnContainer = document.createElement("div");
    brkdwnContainer.classList.add("breakdownContainer");
    brkdwnContainer.innerHTML = this.totalMessage.replace(/\n/g, "<br>");
    this.duelScreen.appendChild(brkdwnContainer);

    // Toggle visibility on click
    showBrkdwnBtn.addEventListener('click', () => {
        brkdwnContainer.classList.toggle("expanded");
        this.duelScreen.classList.toggle("scrollable");
    });
}
```

- **Side effects**: 
  - Sets `this.gameFlag = 0`, halting the game loop.
  - Clears `this.orders`, stopping queued actions.
  - Modifies DOM by adding result UI elements.
  - Logs final messages and combat statistics.
- **Parameters**: None.
- **Returns**: `undefined`.
- **Context**: Called as a method on a `Duel` instance, assumes presence of `charA`, `charB`, `duelScreen`, `totalMessage`, and `startTime`.

---

### Example Usages

The `terminate` method is invoked in two main scenarios: when a character is defeated and cannot revive, or when a time-limited duel ends.

#### 1. Called from `seekTurn` after character defeat

When either combatant’s HP reaches zero and no revival mechanic is active, `terminate` ends the duel.

```javascript
608:614:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
seekTurn () {
    if (this.charB.stats.hpa <= 0 && this.charA.stats.hpa <= 0) {
        this.charA.faint();
        this.charB.faint();
        if (!this.charB.stats.reviveEnchanted && !this.charA.stats.reviveEnchanted) {
            this.terminate(); // Ends duel if neither can revive
        } else {
            // Attempt revive instead
        }
    }
}
```

#### 2. Forced termination after 30 seconds in time-limited mode

A UI button triggers a duel that automatically ends after 30 seconds using `setTimeout`.

```javascript
944:948:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
document.querySelector('.thirtySecondsBtn').addEventListener('click', () => {
    const a = new Duel({duelmode: "normal", japanname: "30びょうでちゅうし", background : 0});
    duelMain.push(a);
    setTimeout(() => { a.seekTurn(); }, 1000);
    setTimeout(() => { a.terminate(); }, 30000); // Ends duel after 30 seconds
});
```

**Usage Summary**:  
`terminate` is called in three conditional branches within `seekTurn` and once directly via `setTimeout`. It is central to ending duels under various conditions: knockout, mutual defeat, or time expiration. It is not exported or used outside the `Duel` class context.

---

### Notes

- `terminate` does **not** reset character stats or remove DOM elements from previous matches — it only appends new ones. This could lead to memory leaks or visual clutter over multiple duels unless manually cleared.
- The method assumes `this.startTime` is set at duel start; if missing, combat duration will be incorrect.
- Even if one character is still alive, a premature `terminate` call (e.g., via time limit) results in a draw — the fallback branch handles this case.

---

### See Also

- `seekTurn`: Primary caller of `terminate`; evaluates game state each turn and decides whether to continue or end the duel.
- `writeMessage` and `writeBreakdown`: Used by `terminate` to update UI and log messages; essential for user feedback.
- `Duel` class: The containing class for `terminate`; manages the lifecycle of a duel instance.
- `reviveEnchanted`: A flag checked before calling `terminate`; determines whether a character can self-revive instead of ending the match.



******************************************
Leadchar.invokeRevive
******************************************
`invokeRevive` is a method that revives a fainted character in a duel when a "Revive" effect is active.  
It restores the character's HP and TP, removes the fainted state, and resumes gameplay after a delay.

---

### Definition

The `invokeRevive` method is a class method within a character controller in a turn-based duel system. It is called when a character who previously received a "Revive" enchantment faints, allowing them to automatically return to battle.

```javascript
347:362:c:\Users\katos\Desktop\2020A-Katoso\autoDueling\assets\js\main.js
invokeRevive () {
    // Notify: Revive magic activates
    this.duel.writeMessage(`しかし ${this.stats.charName} に かかっていたリヴァイブまほうが ${this.stats.charName} に ちからをくれた！`);

    setTimeout(()=>{
        // Revival message
        this.duel.writeMessage(`${this.stats.charName} は カムバックした！`);
        // Disable revive enchant
        this.stats.reviveEnchanted = 0;
        // Restore full HP
        this.stats.hp = this.stats.mhp;
        // Restore 30% of max TP
        this.stats.tp = Math.floor(this.stats.mtp * 0.3);
        // Remove visual "fainted" state
        this.windowMain.classList.remove("fainted");
        // Restart periodic ailment checks
        this.seeking = setInterval(()=>{this.seekAilmentState ();}, 2000);
    },1000);
    
    // Resume turn processing after revival
    setTimeout(()=>{
        this.duel.seekTurn();
    },1800);
}
```

- **Side effects**:  
  - Updates `hp`, `tp`, and `reviveEnchanted` in `this.stats`  
  - Removes `"fainted"` CSS class from `this.windowMain`  
  - Starts a recurring interval for `seekAilmentState()`  
  - Triggers `this.duel.seekTurn()` after delay  
  - Writes two sequential messages to the duel log  

- **Params**: None (method is invoked directly on the character instance)  
- **Returns**: `undefined` (no explicit return value)

This method assumes the character is already in a "fainted" state and that `reviveEnchanted` was previously set to `1` by another game mechanic.

---

### Example Usages

There are **no direct caller references** found for `invokeRevive` in the codebase. It is defined but not explicitly invoked in any visible code. However, based on context, it is likely intended to be called after `faint()` when `reviveEnchanted` is active.

Example invocation logic (inferred):
```javascript
// After character faints, check for revive enchant
if (this.stats.reviveEnchanted) {
    this.invokeRevive(); // Trigger comeback
} else {
    this.duel.terminate(); // Game over
}
```

Despite being defined, **`invokeRevive` has zero callers** in the current codebase. It exists as a standalone method with no observed integration into the duel flow. This suggests it may be:
- A stub for future implementation
- Called indirectly via reflection or string reference (not found in grep)
- Leftover from prior development

---

### Notes

- Despite its clear functionality, `invokeRevive` is **not currently used** anywhere in the codebase — it has no callers.
- The method does **not validate** whether the character is actually fainted before reviving — it assumes prior state checks were made.
- Revival grants **30% of max TP**, which may be a balancing mechanic to prevent immediate reuse of high-cost PSI abilities.

---

### See Also

- `faint()`: Method that puts the character into the fainted state; likely the intended trigger point for `invokeRevive`  
- `reviveEnchanted`: A flag in `this.stats` that indicates whether the revive effect is active — this must be set externally  
- `seekAilmentState()`: Periodic function re-enabled by `invokeRevive` to update visual status effects  
- `duel.seekTurn()`: Resumes the duel turn sequence after revival completes

**************************************
Function : determineMainCharAction   *
**************************************
`determineMainCharAction` is a standalone AI decision function used in an automated duel simulation.  
It determines a character's next action (e.g. attack, defend, heal) based on health, TP, and game rules using probabilistic logic.

---

### Definition

```javascript
752:821:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
function determineMainCharAction(origin) {
    const opinions = [];                     // Stores 10 proposed actions
    const player = origin.stats;             // Shortcut to character stats

    // 0.5% chance to forget current rule (e.g. "nomagic")
    if (Math.random() * 200 <= 1) {
        origin.forget("rule");
    }

    let action;
    for (let i = 0; i < 10; i++) {
        action = "bash";                     // Default action

        // 33% chance to use hypnosis if conditions met
        if (player.tp >= spellBook["hypnosis-alpha"].cost &&
            Math.random() * 3 <= 1 &&
            origin.recognizing.opponentSleeping === 0 &&
            !player.ailments.silenced &&
            origin.recognizing.rule !== "nomagic") {
            action = "hypnosis-alpha";
        }

        // 10% unconditional chance to defend
        if (Math.random() * 10 <= 1) {
            action = "defend";
        }

        // Up to 20% chance to drain TP via PSI Magnet if TP low
        if (Math.random() * 5 <= 1 &&
            player.tp < (player.mtp * 0.3) &&
            !player.ailments.silenced &&
            origin.recognizing.rule !== "nomagic") {
            action = "psimagnet";
        }

        // Healing logic with multiple thresholds
        if (player.tp >= spellBook.lifeup.cost &&
            player.hp < (player.mhp * 0.7) &&
            !player.ailments.silenced &&
            origin.recognizing.rule !== "nomagic") {
            if (player.hpa <= (player.mhp * 0.7) && Math.random() * 6 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= (player.mhp * 0.4) && Math.random() * 3 <= 1) {
                action = "lifeup";
            }
            if (player.hpa <= Math.floor(Math.random() * 40) + 100) {
                action = "lifeup";  // Hard survival threshold
            }
        }

        // In sudden death mode, always bash
        if (origin.recognizing.rule === "suddendeath") {
            action = "bash";
        }

        opinions.push(action);
    }

    // Randomly select one of the 10 generated actions
    const finalDecision = opinions[Math.floor(Math.random() * opinions.length)];
    return finalDecision;
}
```

- **Params**: `origin` – a character instance (likely `LeadChar`) with `.stats`, `.recognizing`, and AI memory methods like `.forget()`
- **Returns**: A string representing the chosen action (`"bash"`, `"defend"`, `"lifeup"`, `"psimagnet"`, or `"hypnosis-alpha"`)
- **Side effects**: None directly; modifies no external state. May trigger `.forget("rule")` on `origin`
- **Logic**: Simulates AI by generating 10 action proposals with weighted randomness, then picks one uniformly at random

---

### Example Usages

The function is called during each turn to decide what a character should do. It is used within the `setAction` method of a character class, which then dispatches the corresponding behavior.

```javascript
228:242:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
setAction() {
    const action = determineMainCharAction(this);  // Get AI decision

    if (action === "bash") {
        this.normalBash(this.opponent);
    } else if (action === "defend") {
        this.defend();
    } else if (action === "lifeup") {
        this.lifeUp();
    } else if (action === "psimagnet") {
        this.psiMagnet();
    } else if (action === "hypnosis-alpha") {
        this.hypnosisAlpha();
    } else {
        this.duel.writeMessage(`${this.stats.charName} は たちすくんだ！`);
    }
}
```

**Usage Flow**:
1. `Duel.seekTurn()` selects the next character to act
2. The character's `initAction()` is called
3. `initAction()` calls `setAction()`
4. `setAction()` calls `determineMainCharAction(this)` to get the AI's choice
5. The chosen action is executed

This function is used **twice per duel turn** (once per character) and runs fully autonomously—no player input is involved.

---

### Notes

- Despite generating 10 proposed actions, the final decision is **uniformly random** across them—there is no majority voting or weighting. This introduces unpredictability, even if most proposals favor one action.
- The healing logic has a **hard survival threshold**: if HP is 100 or below (adjusted by random offset), `lifeup` is chosen regardless of other factors—making characters highly aggressive about self-preservation.
- The 10% chance to `defend` is unconditional and can override healing or spellcasting, potentially leading to suboptimal choices—this mimics hesitation or panic in human players.

---

### See Also

- `LeadChar`: The character class whose instances are passed as `origin`; holds stats, UI elements, and methods like `normalBash()` and `lifeUp()`
- `Duel`: The main game loop class; indirectly calls `determineMainCharAction` via `initAction → setAction` during turns
- `spellBook`: Global object defining PSI spells including `"lifeup"`, `"hypnosis-alpha"`, and `"psiMagnet"` with costs and effects
- `characterNames`: Array of Japanese names (e.g. `"そう"`, `"メイプル"`) used to randomly name characters in logs and messages
- `initAction`: Top-level method that starts the action chain, handling status effects before calling `setAction`


**************************************
Class: Background              *
**************************************
`Background` is a class that manages visual and interactive elements in a duel scene.  
It controls background-specific effects, such as random lightning strikes, and integrates with game logic.

---

### Definition

The `Background` class initializes and manages the visual layer of a duel, including special effects triggered during gameplay. It supports multiple background types, with distinct behaviors based on the `bgId` provided.

```javascript
3:62:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
class Background {
    static maximumBgs = 2;

    constructor(duel, bgSettings) {
        this.duel = duel;
        this.bgSettings = bgSettings;

        this.mat = document.createElement('div');
        this.mat.classList.add('duelBg');
        this.duel.duelScreen.appendChild(this.mat);

        if (this.bgSettings.bgId === 0) {
            this.mat.classList.add('duelBg_00');
            // Adds decorative sprite elements for static background
            const sprite00 = document.createElement('div');
            sprite00.classList.add('duelBg_00__sprites01');
            const sprite00Inner = document.createElement('div');
            sprite00Inner.classList.add('duelBg_00__sprites01__inner');
            sprite00.appendChild(sprite00Inner);
            this.mat.appendChild(sprite00);
        }

        if (this.bgSettings.bgId === 1) {
            this.mat.classList.add('duelBg_01');
            this.gimmickWorking = 0;
            setTimeout(() => {
                this.moveBg01(); // Starts periodic lightning check
            }, 1000);
        }
    }

    moveBg01() {
        const probabilityOfThunder = 300;
        if (Math.random() * probabilityOfThunder <= 1 &&
            this.gimmickWorking === 0 &&
            this.duel.charA.stats.hpa > 0 &&
            this.duel.charB.stats.hpa > 0) {
            this.gimmickWorking = 1;
            const target = Math.random() * 2 <= 1 ? this.duel.charA : this.duel.charB;
            this.duel.writeMessage("らくらいだ！");
            flashScreen("#ffef00", this.duel.duelScreen);

            setTimeout(() => {
                this.gimmickWorking = 0;
                target.takeDamage(Math.floor(Math.random() * 80) + 80, "thunder", true);
                if (Math.random() * 8 <= 1) {
                    target.stats.ailments.paralysed = 1;
                    this.duel.writeMessage(`${target.stats.charName} の からだは しびれてしまった！`);
                }
            }, 600);
        }
        if (this.duel.gameFlag === 1) {
            window.requestAnimationFrame(this.moveBg01.bind(this));
        }
    }
}
```

- **Type**: Class
- **Static property**: `maximumBgs = 2` — defines the number of available background types
- **Constructor params**:
  - `duel`: Reference to the parent `Duel` instance managing the game state
  - `bgSettings`: Object containing `bgId` to determine which background to load
- **Side effects**:
  - Appends a DOM element (`div.duelBg`) to `duel.duelScreen`
  - For `bgId === 1`, starts a recurring animation loop via `requestAnimationFrame`
  - May trigger damage and status effects on characters during gameplay
- **Visual behavior**:
  - `bgId === 0`: Static background with decorative sprites
  - `bgId === 1`: Dynamic background with random lightning gimmick

---

### Example Usages

The `Background` class is instantiated within the `Duel` class initialization, using a background ID determined either by rules or randomness.

```javascript
623:626:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
if (this.rules.background === -1) {
    this.rules.background = Math.floor(Math.random() * Background.maximumBgs);
}
this.duelBg = new Background(this, { bgId: this.rules.background });
```

This snippet shows how the background is selected:
- If `rules.background` is `-1`, it picks a random valid ID using `Background.maximumBgs`
- Then constructs the `Background` instance with `{ bgId: ... }`

Another usage occurs in UI logic to validate background selection:

```javascript
1108:1111:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
if (typeof bgNo === "string" && 
    parseInt(bgNo) <= Background.maximumBgs - 1 && 
    parseInt(bgNo) >= -1) {
    return parseInt(bgNo);
} else {
    return -1;
}
```

This ensures user-selected background IDs are within valid range.

**Overall usage summary**:
- Used exclusively in `main.js`
- Central to duel scene setup
- Referenced in game initialization (`Duel` constructor), UI controls (`setBg`), and dynamic effects (`moveBg01`)
- Two background types implemented, but only `bgId === 1` has active gameplay effects

---

### Notes

- The lightning effect on `bgId === 1` can damage either character at random, making it a neutral hazard.
- The effect only triggers when both characters are alive and the game is running (`gameFlag === 1`), preventing unintended activations post-victory.
- Despite `maximumBgs = 2`, no code exists for `bgId === 2` or higher, suggesting extensibility was planned but not implemented.

---

### See Also

- `Duel`: The main game manager that instantiates `Background`; controls lifecycle and rules
- `setBg`: Utility function that validates background input using `Background.maximumBgs`
- `flashScreen`: External function called by `Background` to create visual flash effects during lightning
- `CharBase`: Receives damage and status effects from `Background`'s lightning gimmick


**************************************
Function : moveBg01                *
**************************************
`moveBg01` is a method in the `Background` class that implements dynamic environmental effects for a specific battle background.

It governs a probabilistic lightning strike mechanic that can damage characters and inflict paralysis, active only during ongoing duels on background ID 1.

---

### Definition

The `moveBg01` method is part of the `Background` class in `main.js`. It is specifically tied to background ID `1` (forest-themed arena) and introduces a periodic environmental hazard — random lightning strikes — during gameplay.

```javascript
34:61:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
moveBg01 () {
    const probabilityOfThunder = 300;
    if (
        Math.random() * probabilityOfThunder <= 1
        && this.gimmickWorking === 0
        && this.duel.charA.stats.hpa > 0
        && this.duel.charB.stats.hpa > 0
    ) {
        this.gimmickWorking = 1;
        const target = Math.random() * 2 <= 1 ? this.duel.charA : this.duel.charB;
        this.duel.writeMessage("らくらいだ！");
        flashScreen("#ffef00", this.duel.duelScreen);

        setTimeout(() => {
            this.gimmickWorking = 0;
            target.takeDamage(Math.floor(Math.random() * 80) + 80, "thunder", true);
            if (Math.random() * 8 <= 1) {
                target.stats.ailments.paralysed = 1;
                this.duel.writeMessage(`${target.stats.charName} の からだは しびれてしまった！`);
            }
        }, 600);
    }
    if (this.duel.gameFlag === 1) {
        window.requestAnimationFrame(this.moveBg01.bind(this));
    }
}
```

- **Type**: Instance method of `Background` class  
- **Side effects**: 
  - Displays messages via `this.duel.writeMessage`
  - Triggers screen flash with `flashScreen`
  - Applies damage and status effects (`paralysed`) to one character
  - Schedules itself recursively using `requestAnimationFrame`
- **Conditions**: Only activates if:
  - Game is running (`this.duel.gameFlag === 1`)
  - No current lightning effect active (`gimmickWorking === 0`)
  - Both characters are alive
- **Behavior**: Runs in a loop via `requestAnimationFrame`, checking each frame for a chance (1 in 300) to trigger lightning.

This method effectively creates a passive, turnless hazard unique to one battlefield.

---

### Example Usages

`moveBg01` is automatically invoked when a duel starts on background ID `1`, after a 1-second delay, and then continues to run via animation frame scheduling.

```javascript
25:31:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
if (this.bgSettings.bgId === 1) {
    this.mat.classList.add('duelBg_01');
    this.gimmickWorking = 0;
    setTimeout(() => {
        this.moveBg01();
    }, 1000);
}
```

This snippet shows the **only direct call** to `moveBg01`. After initialization, the method keeps itself alive through `requestAnimationFrame`, meaning it runs continuously as long as the game state allows.

**Usage Summary**:
- Called once at startup for background ID 1
- Self-sustaining via `requestAnimationFrame`
- No external callers; fully encapsulated within `Background` instance logic
- Not used for any other background (`bgId !== 1`)

It is **not widely used** across the codebase — only referenced in three locations: definition, initial call, and recursive scheduling.

---

### Notes

- Despite its name, `moveBg01` does **not animate or move** the background visually — instead, it triggers gameplay events (lightning strikes).
- The name may be misleading: "move" likely refers to "action" or "gimmick activation", not visual motion.
- The 1-second delay before first call (`setTimeout(..., 1000)`) prevents immediate activation, possibly to allow UI stabilization before effects begin.

---

### See Also

- `Background`: The class that owns `moveBg01`; responsible for setting up visual and mechanical aspects of the duel stage.
- `gimmickWorking`: A state flag used to prevent overlapping lightning effects; ensures only one strike occurs at a time.
- `flashScreen`: A utility function called by `moveBg01` to simulate lightning flash, using color `#ffef00` (bright yellow).
- `takeDamage`: Method on character objects (`charA`, `charB`) used to apply 80–159 damage from lightning.
- `duelBg_01`: CSS class applied to the background element when `bgId === 1`, likely tied to visual styling of the forest stage.

*******************************
Drum Meters                   *
*******************************

`drumMeters` is a constant array of DOM elements representing a 4-digit mechanical drum counter display.  
It visually simulates a retro-style rotating drum meter (like those on old odometers) using CSS transforms and background images.

---

### Definition

The `drumMeters` variable is defined as a constant array containing four dynamically created `<div>` elements, each corresponding to one digit in a 4-digit display. These elements are styled and positioned to form a horizontal row of rotating drums, where each drum scrolls vertically to simulate rotation.

```javascript
28:34:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/drummeter.html
const drumMeters = [
    document.createElement("div"),
    document.createElement("div"),
    document.createElement("div"),
    document.createElement("div"),
];
```

Each element in `drumMeters` is styled and appended to a container `.drum_container`. The styling includes:

- Background image (`./assets/images/drummeter.png`) for the drum face.
- Gradient overlay on the first three drums to simulate lighting/depth.
- Absolute positioning, 80px width, and variable height based on digit place value.
- Smooth vertical translation via CSS `transform` for animation.

After creation, these elements are configured in a loop and added to the DOM.

Basic information:
- **Type**: `const drumMeters: HTMLElement[]`
- **Length**: 4 (one per digit, from thousands to units)
- **Side effects**: Modifies DOM by appending 4 styled `<div>`s to `.drum_container`
- **Usage**: Controlled via `syncronize(param)` to display a 4-digit number (0–9999)

---

### Example Usages

The primary use of `drumMeters` is in the `syncronize(param)` function, which updates the vertical position of each drum to reflect a given number. For example, to display `1234`, the thousands drum shifts down by 1×120px, the hundreds by 2×120px, etc.

```javascript
58:65:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/drummeter.html
drumMeters[0].style.transform = 
    `translateY(${(Math.floor(destParam / 1000) * 120) * -1}px)`;
drumMeters[1].style.transform = 
    `translateY(${(Math.floor(destParam / 100) * 120) * -1}px)`;
drumMeters[2].style.transform = 
    `translateY(${(Math.floor(destParam / 10) * 120) * -1}px)`;
drumMeters[3].style.transform = 
    `translateY(${(destParam * 120) * -1}px)`;
```

This code calculates how many "drum segments" (each 120px high) to shift each drum upward (hence `*-1`) based on digit place.

User input from an `<input class="targetChanger">` triggers updates:
```javascript
68:71:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/drummeter.html
document.querySelector('.targetChanger').addEventListener('input', (e)=>{
    tgtParam = e.target.value;
    syncronize(tgtParam);
});
```

This makes `drumMeters` respond in real time to user input, updating the visual counter.

Overall, `drumMeters` is used exclusively in `drummeter.html`, serving as the core visual component of a standalone drum meter widget. There are no external callers or dependencies beyond this file.

---

### Notes

- **Non-linear drum heights**: The height of each drum element is scaled exponentially:  
  ```javascript
  drumMeters[i].style.height = (120 * (10000 / 10 ** (3 - i))) + "px";
  ```
  This ensures lower-place drums (like units) have more segments visible, allowing smooth looping during animation.

- **Performance via CSS transforms**: Instead of repositioning via `top` or `margin`, `translateY` is used—this leverages GPU acceleration for smoother animation with `transition: transform 0.3s`.

- **Visual hierarchy via gradient**: Only the first three drums have a gradient overlay (`rgba(255, 120, 120, 0)`), likely to simulate a highlight on non-units digits, adding depth.

---

### See Also

- `syncronize(param)`: Function that drives `drumMeters` by updating their `transform` values based on a number input.
- `drumContainer`: The parent DOM element (`<div class="drum_container">`) that holds all `drumMeters` and clips overflow to create the "windowed" view.
- `./assets/images/drummeter.png`: Background image used for all drums—likely a repeating vertical strip of digits 0–9.

***************************************
Class: drummeter
***************************************

DrumMeter is a JavaScript class that creates a visual drum-style meter for displaying numeric values in a UI.

It implements an animated, segmented counter resembling mechanical drums in old-school arcade or pinball machines, commonly used to display HP (hit points) and TP (technical points) in game interfaces.

---

### Definition

```javascript
3:60:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
class DrumMeter {
    constructor(location, initialParam = 0, label = "HP") {
        // Create outer container and label
        this.drumContainer = document.createElement('div');
        this.drumContainer.classList.add('drum_container');

        this.labeller = document.createElement("span");
        this.labeller.classList.add("labeller");
        this.labeller.textContent = label;
        this.drumContainer.appendChild(this.labeller);

        // Inner container for the drum segments
        this.drumContainerInner = document.createElement('div');
        this.drumContainerInner.classList.add('drum_container_inner');
        this.drumContainer.appendChild(this.drumContainerInner);
        location.appendChild(this.drumContainer);

        // Create four drum segments (for thousands, hundreds, tens, units)
        this.drumMeters = [
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
            document.createElement("div"),
        ];

        for (let i = 0; i < 4; i++) {
            // Apply background: gradient + drum texture for first three; full repeat for last
            this.drumMeters[i].style.background = i !== 3 
                ? "linear-gradient(...) left top no-repeat, url(./assets/images/drumme..." 
                : "url(./assets/images/drummeter.png) left top repeat-y";

            this.drumMeters[i].style.backgroundSize = "80px";
            this.drumMeters[i].style.width = "80px";
            this.drumMeters[i].style.position = "absolute";
            this.drumMeters[i].style.left = (80 * i) + "px";
            this.drumMeters[i].style.top = "0";
            this.drumMeters[i].style.height = (120 * (10000 / 10 ** (3 - i))) + "px";
            this.drumMeters[i].style.transition = "transform 0.1s ease-in-out";
            if (i < 3) this.drumMeters[i].style.transitionDelay = "0.1s";

            this.drumContainerInner.appendChild(this.drumMeters[i]);
        }

        this.syncronize(initialParam); // Set initial value
    }

    syncronize(param) {
        let destParam = Math.max(0, Math.min(param, 9999)); // Clamp to 0–9999

        // Each drum moves vertically to show correct digit
        this.drumMeters[0].style.transform = `translateY(${(Math.floor(destParam / 1000) * 120) * -1}px)`;
        this.drumMeters[1].style.transform = `translateY(${(Math.floor(destParam / 100) * 120) * -1}px)`;
        this.drumMeters[2].style.transform = `translateY(${(Math.floor(destParam / 10) * 120) * -1}px)`;
        this.drumMeters[3].style.transform = `translateY(${(destParam % 10 * 120) * -1}px)`;
    }
}
```

- **Type**: Class
- **Purpose**: Visual representation of a 4-digit number using animated vertical drums
- **Params**:
  - `location`: DOM element where the meter will be inserted
  - `initialParam`: Initial numeric value (default: 0)
  - `label`: Text label shown above the meter (default: "HP")
- **Side effects**: Modifies the DOM by appending a complex UI structure; applies CSS transitions for animation
- **Internal structure**:
  - `drumMeters`: Array of 4 `<div>` elements, each simulating one digit wheel
  - Each drum uses `background-image` and `transform: translateY()` to simulate rotation
  - Digit height is 120px, so each step moves -120px vertically
- **Value range**: Clamped between 0 and 9999

---

### Example Usages

The `DrumMeter` class is used to display character stats in a duel interface, specifically HP and TP values.

```javascript
358:359:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
this.hpindicator = new DrumMeter(this.windowMain, this.stats.hpa, "HP");
this.tpindicator = new DrumMeter(this.windowMain, this.stats.tpa, "TP");
```

These lines create two drum meters:
- One for **HP** (hit points), initialized with `this.stats.hpa`
- One for **TP** (technical points), initialized with `this.stats.tpa`

They are attached to `this.windowMain`, which is likely a character status panel in the UI.

Overall, `DrumMeter` is used exactly twice in the codebase (based on references), both within what appears to be a character UI initialization routine. This suggests it's a specialized UI component used only for primary stat display, not reused for other numeric values.

---

### Notes

- Despite being named "DrumMeter", it doesn't actually rotate — it uses vertical scrolling (`translateY`) of a long background image to simulate drum movement.
- The first three drums have a gradient overlay (likely to simulate lighting/shading), while the units digit uses a simpler repeated texture.
- The use of `transition-delay` on the first three drums creates a cascading animation effect when updating, enhancing the mechanical feel.

---

### See Also

- `this.stats.hpa`: Current HP value used to initialize the HP drum meter; represents a character's remaining hit points
- `this.stats.tpa`: Current TP value used for the TP drum meter; tracks technical/ability resources
- `drum_container`, `drum_container_inner`: CSS classes applied to container elements; likely styled in an external stylesheet to position and size the meter
- `./assets/images/drummeter.png`: Background image used for the drum segments; contains repeating digits or tick marks to simulate a spinning wheel



**************************************
Function : duelOutcomeNotify          *
**************************************
`duelOutcomeNotify` is a function that displays a temporary popup notification when a duel concludes.  
It conditionally shows outcome messages (e.g., victory, draw) only if the duel screen is not in the current viewport.

---

### Definition

The `duelOutcomeNotify` function creates a transient UI popup to inform the user of a duel’s result—such as a win, loss, or draw—without interrupting the flow. It intelligently avoids displaying the notification if the duel screen is already visible on the user’s screen, preventing redundant alerts.

It is primarily used in the `terminate` method of a duel instance to summarize the outcome after combat ends.

```javascript
1182:1221:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
function duelOutcomeNotify(msg, duelScreenPosition, isPipped = 0) {
    const vport = [window.scrollY, window.scrollY + window.innerHeight];

    // If duel screen is already in view, do not show notification
    if (vport[0] < duelScreenPosition[0] && vport[1] > duelScreenPosition[1]) {
        console.log("表示しません"); // "Not showing"
    } else {
        if (!isPipped) {
            const popup = document.createElement('div');
            popup.classList.add('duelOutcomePopup');
            popup.textContent = msg;
            popup.addEventListener('click', () => {
                // Scroll to duel screen when clicked
                window.scrollTo({ top: duelScreenPosition[0], behavior: 'smooth' });
                popup.classList.remove("expanded");
            });
            document.querySelector('main').appendChild(popup);
            popup.classList.add('onBottom'); // Position based on viewport
            setTimeout(() => popup.classList.add('expanded'), 17);
            setTimeout(() => popup.classList.remove('expanded'), 4700);
            setTimeout(() => popup.remove(), 5000); // Auto-remove after 5s
        }
    }
}
```

- **Params**:
  - `msg`: The message to display (e.g., "Player A のしょうり！").
  - `duelScreenPosition`: A two-element array `[top, bottom]` indicating the vertical bounds of the duel screen in the document.
  - `isPipped`: Optional flag (default: 0) to suppress notification (likely used for embedded/pip-mode displays).
- **Side effects**: Appends a DOM element to `<main>`, adds event listeners, and triggers smooth scrolling on click.
- **Returns**: `undefined` — purely a UI side-effect function.

---

### Example Usages

`duelOutcomeNotify` is called in the `terminate` method of a duel object when the battle ends. It reports outcomes like victory, draw, or cancellation.

For example, when both characters are defeated:

```javascript
1018:1018:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
duelOutcomeNotify(
  `${this.duelTitle} - ひきわけに なった！`, 
  [this.duelScreen.offsetTop, this.duelScreen.offsetTop + this.duelScreen.offsetHeight],
  this.duelScreen.classList.contains('pseudoPipped') // Prevents popup in PIP mode
);
```

Similarly, it is used to announce a winner:

```javascript
1023:1023:/c:/Users/katos/Desktop/2020A-Katoso/autoDueling/assets/js/main.js
duelOutcomeNotify(
  `${this.duelTitle} - ${this.charA.stats.charName} のしょうり！`,
  [this.duelScreen.offsetTop, this.duelScreen.offsetTop + this.duelScreen.offsetHeight],
  this.duelScreen.classList.contains('pseudoPipped')
);
```

**Usage Summary**:  
The function is invoked **five times** in the codebase, all within the `terminate` method of what appears to be a `Duel` class. It handles all end-of-duel states:
- Win for character A
- Win for character B
- Mutual defeat (draw)
- Canceled duel
- Revive failure (treated as draw)

It is **not used elsewhere**, making it a tightly scoped utility for post-duel feedback.

---

### Notes

- **Viewport-aware behavior**: The function checks whether the duel screen is currently visible using `window.scrollY` and `innerHeight`. If the duel is in view, it suppresses the popup to avoid distraction.
- **Auto-dismissing UI**: The notification appears with a CSS class `expanded`, then fades out after 4.7 seconds and is removed after 5 seconds.
- **Click-to-navigate**: Clicking the popup smoothly scrolls the page to the duel screen, acting as both notification and navigation aid.

---

### See Also

- `terminate`: The method in the duel logic that ends the match and calls `duelOutcomeNotify` to report results.
- `seekTurn`: The main duel loop function that eventually leads to `terminate` being called when a character is defeated.
- `pseudoPipped`: A CSS class (or flag) used to conditionally disable the notification, likely for picture-in-picture or embedded views.